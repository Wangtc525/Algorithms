# C++ Tips
## STL

### map

### hashmap

插入元素：
``` c++
unordered_map<string, int> unomap;
unomap.emplace(key, value); 
或者 unomap[key]=value;
```

判断元素存在：

``` c++
map.find(val)!=map.end();
map.count(val)!=0;
```

删除元素：

```c++
map.erase(val);
```
### vector

### priority_queue

#### 自定义比较举例

``` c++
struct cmp{
    bool operator()(pair<int,int> a, pair<int,int> b){
        return a.second < b.second;
    }
    
};
priority_queue<pair<int,int>,vector<pair<int,int>>,cmp>pq; 
```

## 字符串

判断一个字符是否为字母

`isalpha()`

是否为数字

`isdigit()`

是否为数字或字母

`isalnum()`

大写字母转小写


`tolower()`

小写字母转大写

`toupper()`
## 常用函数

### 翻转数组

``` c++
    void reverse(vector<int> &nums, int begin, int end)
    {
        while(begin<end){
            swap(nums[begin], nums[end]);
            begin++;
            end--;
        }
    }
```


# 力扣题目
## 面试经典150题
5月份刷穿面试热门150道。
### 完成表

| 日期   | 完成题数 | 完成题号| 难题（很难理解）|  未独立做出| 独立做出但存在优化空间| 
|:-------: | :-----: | :-----: |:-------:|:-------:|:-------:
| 5月3日 | 2 |001-002|       |
| 5月4日 | 8|003-010| 8,10|
| 5月5日| 3 |011-013||
| 5月6日| 10 |14-23|22,23|14，15，16，22，23
| 5月17日|6| 24-29| |24,29
| 总计| 29 ||

### 数组 / 字符串

[【001】合并两个有序数组](Leetcode/88.合并两个有序数组.cpp)

这道题开始采用的从前往后合并，但需要新开辟一个空间。最优的方法应该是从后往前遍历，不需要开辟新的空间。

[【002】移除元素](Leetcode/27.移除元素.cpp)

这道题从前往后遍历等于val的元素，出现后开始从后往前找不是val的元素，然后交换，当首尾指针交汇的时候，循环结束。每次循环都需要cnt+1。

[【003】删除有序数组中的重复项](Leetcode/26.删除有序数组中的重复项.cpp)

两个指针i和j，j比i靠后，如果nums[j]<=nums[i]，就继续往前走，直到j==n或者nums[j]>nums[i]时。缺点是快指针遍历次数显然大于n。

快慢指针均只需要移动n次的办法：定义快慢指针，然后循环终止条件为fast>=n，对于fast指针，如果它和fast-1不一样，则赋值给low,同时low+1,反之则fast继续往后遍历。


[【004】删除有序数组中的重复项 II](Leetcode/80.删除有序数组中的重复项-ii.cpp)

在【003】的基础之上，因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 nums[slow−2] 是否和当前待检查元素 nums[fast] 相同。当且仅当 nums[slow−2]=nums[fast] 时，当前待检查元素 nums[fast]不应该被保留（因为此时必然有 nums[slow−2]=nums[slow−1]=nums[fast]）。最后，slow 即为处理好的数组的长度。


[【005】多数元素](Leetcode/169.多数元素.cpp)

排序或者摩尔投票法。

[【006】轮转数组](Leetcode/189.轮转数组.cpp)

可以申请一个额外数组空间，直接赋值，但需要额外内存。

考虑原地方法：数组翻转
nums = "----->-->"; k =3

result = "-->----->";

reverse "----->-->" 可得 "<--<-----"

reverse "<--" 可得 "--><-----"

reverse "<-----" 可得 "-->----->"



[【007】买卖股票的最佳时机](Leetcode/121.买卖股票的最佳时机.cpp)

子结构定义为每天的利润，记录一个最小值，然后遍历数组，同时判断每天的利润

[【008】买卖股票的最佳时机 II](Leetcode/122.买卖股票的最佳时机-ii.cpp) `!!!`

本题可以采用贪心或者动态规划。

贪心思路：

遍历每一天，累加最大利润。

本题动态规划法的思路：

因为，从最后一天往前看，分成四种情况：

    A：前一天有股票，并卖出 -- 剩余股票数0

    B：前一天没有股票，并不买入 -- 剩余股票数0

    C：前一天有股票，并不买出 -- 剩余股票数1

    D：前一天没有股票，并买入 -- 剩余股票数1

所以：

    当剩余股票数0时，最大的利润是max(A, B)

    当剩余股票数1时，最大的利润是max(C, D)

[【009】跳跃游戏](Leetcode/55.跳跃游戏.cpp)

贪心：挨个跳，每次记录最大可以跳跃的距离，如果当前位置>大于当前可以跳跃到的最大距离，则返回false,否则，循环结束后返回true。

动态规划：

定义dp数组，dp[0]=nums[0]

从下标i出发，最大能到达nums[i]+i处

不从下标i出发，最大能达到dp[i-1]处

[【010】跳跃游戏 II](Leetcode/45.跳跃游戏-ii.cpp) ` !!! `

初级办法：依次遍历数组，更新每个位置i所能到达的其他位置j的最小步数，最小步数等于cnt[j]=min(nums[i]+1,cnt[j])

优化：


[【011】H 指数](Leetcode/274.h-指数.cpp)

这道题从小到大排个序就行，唯一需要注意的是先给数组后面加一个0，用来避免特殊情况。

[【012】0（1)时间插入、删除和获取随机元素](Leetcode/380.o-1-时间插入、删除和获取随机元素.cpp)

`变长数组`可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在O(1) 的时间内判断元素是否存在，因此不能在 O(1) 的时间内完成插入和删除操作。

`哈希表`可以在 O(1)的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O(1) 的时间内完成获取随机元素操作。

为了满足插入、删除和获取随机元素操作的时间复杂度都是 O(1)，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。

`有一个需要注意的地方就是，删除vector中指定位置的元素，应该是先将最后一个元素放到该位置，然后删除最后一个元素。`

[【013】除自身以外数组的乘积](Leetcode/238.除自身以外数组的乘积.cpp)

算两个前缀，前缀乘和后缀乘。然后到某一个元素后将两者乘起来就行。

[【014】加油站](Leetcode/134.加油站.cpp)

一次遍历：从0开始，找到最低点，最低点最有可能是起点，同时，特判下无解的情况。

[【015】分发糖果](Leetcode/135.分发糖果.cpp)

分别从左和从右遍历，初值均设置为1，计算符合糖果分配的策略，然后两者在每个孩子的地方取最大值，即是最终的办法。

[【016】接雨水](Leetcode/42.接雨水.cpp)

单调栈：单调递减栈，单调栈里面存储每个height的下标。首先入栈0，然后遍历数组，当height[i]大于栈顶元素，直接入栈；当height[i]大于栈顶元素时，意味着存在可以存雨水的地方，那么就将栈顶元素弹出，接下来判断i和此时栈顶元素最低点l，减去弹出的数值，即为高，然后宽度为i-l-1，那么面积就知道了，依次累加。

[【017】罗马数字转整数](Leetcode/13.罗马数字转整数.cpp)

用一个栈来模拟，如果栈不空，判断和栈顶元素大小关系，如果当前元素小于栈顶元素，则直接计算当前栈里面的所有数值，并将当前元素入栈，如果大于，那说明这一组罗马数字存在减的情况；如果栈空，直接入栈。

[【018】整数转罗马数字](Leetcode/12.整数转罗马数字.cpp)

贪心+哈希表。

[【019】最后一个单词的长度](Leetcode/58.最后一个单词的长度.cpp)

从后往前遍历即可。

[【020】最长公共前缀](Leetcode/14.最长公共前缀.cpp)

每次都记录最小匹配长度，然后基于最小匹配长度开始下一轮匹配。唯一需要注意string的构造函数`string s=string(str,begin,end),表示将str的begin到end的子字符串赋值给s`。

[【021】反转字符串中的单词](Leetcode/151.反转字符串中的单词.cpp)

先逆序，再每个单词换一下顺序即可，可以实现原地反转。

[【022】N字形变换](Leetcode/6.n-字形变换.cpp)

没想明白。

[【023】找出字符串中第一个匹配项的下标](Leetcode/28.找出字符串中第一个匹配项的下标.cpp)

`KMP`。[KMP算法介绍](https://www.zhihu.com/question/21923021/answer/281346746)
重点在于一个前缀和后缀。对于字串而言，需要对应一个next数组，这个数组的意义在于记录的是当前索引对应的前缀和后缀的最大匹配长度。当匹配不成功的时候，通过对应位置的next数组值，将字串的索引j移动至对应位置。

`计算next数组时，实际就是两个子串的模式匹配，不过需要注意，待匹配的字串应该从匹配的子串的第2位开始（前缀后缀匹配）。`



[【024】文本左右对齐](/Users/wangtengcheng/wtc/program/C_Cxx_program/Algorithm/Leetcode/68.文本左右对齐.cpp)

按题目要求模拟即可

### 双指针

[【025】验证回文串](Leetcode/125.验证回文串.cpp)

双指针模拟即可。

[【026】判断子序列](Leetcode/392.判断子序列.cpp)


双指针模拟即可。

[【027】两数之和III-输入有序数组](Leetcode/167.两数之和-ii-输入有序数组.cpp)

双指针模拟即可。如果两数之和大于target，则右边前移，小于的话则左边后移，否则直接答案。

[【028】盛最多水的容器](/Users/wangtengcheng/wtc/program/C_Cxx_program/Algorithm/Leetcode/11.盛最多水的容器.cpp)

双指针模拟。如果左边大，那么右边前移，否则，左边后移。同时记录最大值。

[【029】三数之和](Leetcode/15.三数之和.cpp)

先排序再双指针，记得去重。去重原则是相同的数只作为一个指针一次。

### 滑动窗口

[【030】长度最小的子数组]()

[【031】无重复字符的最长子串]()

[【032】串联所有单词的子串]()

[【033】最小覆盖子串]()


### 矩阵

[【034】有效的数独]()

[【035】螺旋矩阵]()

[【036】旋转图像]()

[【037】矩阵置零]()

[【038】生命游戏]()


### 哈希表

[【039】赎金信]()

[【040】同构字符串]()

[【041】单词规律]()

[【042】有效的字母异或词]()

[【043】字母异或词分组]()

[【044】两数之和]()

[【045】快乐数]()

[【046】存在重复元素 II]()

[【047】最长连续序列]()

### 区间

[【048】汇总区间]()

[【049】合并区间]()

[【050】插入区间]()

[【051】用最少数量的箭引爆气球]()


### 栈

[【052】有效的括号]()

[【053】简化路径]()

[【054】最小栈]()

[【055】逆波兰表达式求值]()

[【056】基本计算器]()


### 链表

[【057】环形链表]()

[【058】两数相加]()

[【059】合并两个有序链表]()

[【060】复制带随机指针的链表]()

[【061】反转链表 II]()

[【062】K 个一组翻转链表]()

[【063】删除链表的倒数第 N 个结点]()

[【064】删除排序链表中的重复元素 II]()

[【065】旋转链表]()

[【066】分隔链表]()

[【067】LRU 缓存]()

### 二叉树

[【068】二叉树的最大深度]()

[【069】相同的树]()

[【070】翻转二叉树]()

[【071】对称二叉树]()

[【072】从前序与中序遍历序列构造二叉树]()

[【073】从中序与后序遍历序列构造二叉树]()

[【074】填充每个节点的下一个右侧节点指针 II]()

[【075】二叉树展开为链表]()

[【076】路径总和]()

[【077】求根节点到叶节点数字之和]()

[【078】二叉树中的最大路径和]()

[【079】二叉搜索树迭代器]()

[【080】完全二叉树的节点个数]()

[【081】二叉树的最近公共祖先]()

### 二叉树层序遍历

[【082】二叉树的右视图]()

[【083】二叉树的层平均值]()

[【084】二叉树的层序遍历]()

[【085】二叉树的锯齿形层序遍历]()


### 二叉搜索树

[【086】二叉搜索树的最小绝对差]()

[【087】二叉搜索树中第K小的元素]()

[【088】验证二叉搜索树]()


### 图

[【089】岛屿数量]()

[【090】被围绕的区域]()

[【091】克隆图]()

[【092】除法求值]()

[【093】课程表]()

[【094】课程表 II]()

### 图的广度优先搜索

[【095】蛇梯棋]()

[【096】最小基因变化]()

[【097】单词接龙]()


### 字典树

[【098】实现 Trie (前缀树)]()

[【099】添加与搜索单词 - 数据结构设计]()

[【100】单词搜索 II]()

### 回溯

[【101】电话号码的字母组合]()

[【102】组合]()

[【103】全排列]()

[【104】组合总和]()

[【105】N 皇后 II]()

[【106】括号生成]()

[【107】单词搜索]()

### 分治

[【108】将有序数组转换为二叉搜索树]()

[【109】排序链表]()

[【110】建立四叉树]()

[【111】合并 K 个升序链表]()


### Kadane 算法

[【112】最大子数组和]()

[【113】环形子数组的最大和]()


### 二分查找

[【114】搜索插入位置]()

[【115】搜索二维矩阵]()

[【116】寻找峰值]()

[【117】搜索旋转排序数组]()

[【118】在排序数组中查找元素的第一个和最后一个位置]()

[【119】寻找旋转排序数组中的最小值]()

[【120】寻找两个正序数组的中位数]()

### 堆

[【121】数组中的第K个最大元素]()

[【122】IPO]()

[【123】查找和最小的 K 对数字]()

[【124】数据流的中位数]()

### 位运算

[【125】二进制求和]()

[【126】颠倒二进制位]()

[【127】位1的个数]()

[【128】只出现一次的数字]()

[【129】只出现一次的数字 II]()

[【130】数字范围按位与]()

### 数学

[【131】回文数]()

[【132】加一]()

[【133】阶乘后的零]()

[【134】x 的平方根]()

[【135】Pow(x,n)]()

[【136】直线上最多的点数]()

### 一维动态规划

[【137】爬楼梯]()

[【138】打家劫舍]()

[【139】单词拆分]()

[【140】零钱兑换]()

[【141】最长递增子序列]()


### 多维动态规划

[【142】三角形最小路径和]()

[【143】最小路径和]()

[【144】不同路径 II]()

[【145】最长回文子串]()

[【146】交错字符串]()

[【147】编辑距离]()

[【148】买卖股票的最佳时机 III]()

[【149】买卖股票的最佳时机 IV]()

[【150】最大正方形]()
